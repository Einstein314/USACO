#pragma GCC optimize ("O3")
#pragma GCC target ("sse4")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef vector<pii> vii;

typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

#define FOR(i,a,b) for (int i = a; i < b; i++)
#define F0R(i,a) for (int i = 0; i < a; i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i>=0; i--)
#define pb push_back
#define all(x) x.begin(), x.end()



int n, x[105], y[105];

int parent[105], sz[105]; //where n is number of vertices, note change this to n+1 if your vertices are numbered 1 to n  

void make_set(int v){
	parent[v] = v;
	sz[v] = 1;
}

int find_set(int v){
	if (v == parent[v]) return v;
	return parent[v] = find_set(parent[v]);
}

bool same(int a, int b){
	return find_set(a) == find_set(b);
}

void union_sets(int a, int b){
	a = find_set(a);
	b = find_set(b);
	if (a != b){
		if (sz[a] < sz[b]) swap(a,b);
		parent[b] = a;
		sz[a] += sz[b];
	}
}


set<int> st;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

	cin >> n;
	F0R(i,n){
		cin >> x[i+1] >> y[i+1];
	}
	F0R(i,n) make_set(i+1);
	F0R(i,n){
		FOR(j, i+1, n){
			if (x[i+1] == x[j+1] || y[i+1] == y[j+1]) union_sets(i+1, j+1);
		}
	}
	F0R(i,n){
		st.insert(find_set(i+1));
	}
	int tsz = st.size() - 1;
	cout << tsz << "\n";
		

    return 0;

}
