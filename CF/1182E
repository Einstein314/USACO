#pragma GCC optimize ("O3")
#pragma GCC target ("sse4")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef vector<pii> vii;

typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

#define FOR(i,a,b) for (int i = a; i < b; i++)
#define F0R(i,a) for (int i = 0; i < a; i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i>=0; i--)
#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

ll n, f1, f2, f3, c, rec;

const ll mod = 1e9 + 7;
const ll tmpx = mod - 1;

ll modpow(ll f, ll e){
    if (e == 0) return 1;
    ll x = modpow(f * f % mod, e>>1);
    return e & 1 ? x * f % mod : x;
}


template<class T> struct Mat {
    T** d;
    int a, b;
    Mat() { a = b = 0; }
    Mat(int _a, int _b) : a(_a), b(_b) {
        d = new T*[a];
        F0R(i,a) {
            d[i] = new T[b];
            F0R(j,b) d[i][j] = 0;
        }
    }
    
    Mat (const vector<vector<T>>& v) : Mat(sz(v),sz(v[0])) {
        F0R(i,a) F0R(j,b) d[i][j] = v[i][j];
    }
    
    
    Mat operator*(const Mat& m) {
        assert(b == m.a);
        Mat r(a,m.b);
        F0R(i,a){
            F0R(j,b){
                F0R(k,m.b){
                    ll tt1 = d[i][j];
                    ll tt2 = m.d[j][k];
                    ll tt3 = (tt1 * tt2) % tmpx;
                    r.d[i][k] += (tt3 + tmpx);
                    r.d[i][k] %= tmpx;
                }
            }
        }
        return r;
    }
    
    Mat& operator*=(const Mat& m) { return *this = (*this)*m; }
    
    friend Mat exp(Mat m, ll p) {
        Mat r(m.a,m.a); assert(m.a == m.b);
        F0R(i,m.a) r.d[i][i] = 1;
        for (; p; p /= 2, m *= m){
            if (p&1) r *= m;
        }
        return r;
    }

};


int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> f1 >> f2 >> f3 >> c;
    
    Mat<ll> m1({{0,1,0},{0,0,1},{1,1,1}});
    
    Mat<ll> ta1({{1},{0},{0}});
    Mat<ll> ta2({{0},{1},{0}});
    Mat<ll> ta3({{0},{0},{1}});

    Mat<ll> bg1({{0,1,0,0,0},{0,0,1,0,0},{0,0,0,1,0},{0,0,0,0,1},{1,-1,0,-2,3}});
    Mat<ll> tr1({{0},{0},{0},{2},{6}});
    
    Mat<ll> tmp = exp(m1, n-1);
    Mat<ll> tmp1 = tmp * ta1;
    Mat<ll> tmp2 = tmp * ta2;
    Mat<ll> tmp3 = tmp * ta3;
    
    Mat<ll> bgtmp = exp(bg1, n-1);
    Mat<ll> ltmp = bgtmp * tr1;
    

    ll an = tmp1.d[0][0];
    an %= tmpx;
    ll bn = tmp2.d[0][0];
    bn %= tmpx;
    ll cn = tmp3.d[0][0];
    cn %= tmpx;
    ll fn = ltmp.d[0][0];
    fn %= tmpx;
    
    
    

    
    
    
    ll fan = modpow(f1, an);
    ll fbn = modpow(f2, bn);
    ll fcn = modpow(f3, cn);
    ll cfn = modpow(c, fn);
    

    rec = 1;
    rec = (rec * fan) % mod;
    rec = (rec * fbn) % mod;
    rec = (rec * fcn) % mod;
    rec = (rec * cfn) % mod;
    cout << rec << "\n";





    return 0;
}
