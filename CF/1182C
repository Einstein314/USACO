#pragma GCC optimize ("O3")
#pragma GCC target ("sse4")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef vector<pii> vii;

typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

#define FOR(i,a,b) for (int i = a; i < b; i++)
#define F0R(i,a) for (int i = 0; i < a; i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i>=0; i--)
#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) int((x).size())
#define f first
#define s second 
#define newl '\n'
// #define mp make_pair

int n, m, maxvcnt;
string a[100500];
map<char,int> mp = {{'a', 1}, {'e', 2}, {'i', 3}, {'o', 4}, {'u', 5}};
vector<string> adj[100500][6];
vector<string> lft[100500];
vector<pair<string, string> > scd, cd;

int main(){
   // ios::sync_with_stdio(0);
   // cin.tie(0);
   
   cin >> n;
   F0R(i,n){
	   cin >> a[i];
	   int l = a[i].length();
	   int vcnt = 0, ind = 0;
	   bool lst = 0;
	   F0Rd(j, l){
		   if (mp[a[i][j]]){
			   if (!lst){
				  ind = j;
				  lst = 1; 
			   }
			   vcnt++;
		   }
	   }
	   maxvcnt = max(maxvcnt, vcnt);
	   adj[vcnt][mp[a[i][ind]]].pb(a[i]);
   }
   FOR(i, 1, maxvcnt+1){
	   FOR(j, 1, 6){
		   int ti = 0;
		   while (ti < sz(adj[i][j]) - 1){
			   cd.pb(make_pair(adj[i][j][ti], adj[i][j][ti+1]));
			   ti += 2;
		   }
		   if (ti <= sz(adj[i][j]) - 1){
			   lft[i].push_back(adj[i][j][ti]);
		   }
	   }
   }
   FOR(i, 1, maxvcnt + 1){
	   int ti = 0;
	   while (ti < sz(lft[i]) - 1){
		   scd.pb(make_pair(lft[i][ti], lft[i][ti+1]));
		   ti += 2;
	   }
   }    
   if (sz(scd) >= sz(cd)){
	   cout << sz(cd) << newl;
	   F0R(i, sz(cd)){
		   cout << scd[i].f << " " << cd[i].f << newl << scd[i].s << " " << cd[i].s << newl;
	   }
   }
   else{
	   cout << sz(scd) + (sz(cd) - sz(scd))/2 << newl;
	   F0R(i, sz(scd)){
		   cout << scd[i].f << " " << cd[i].f << newl << scd[i].s << " " << cd[i].s << newl;
	   }
	   int ti = sz(scd);
	   while (ti < sz(cd) - 1){
		   cout << cd[ti].f << " " << cd[ti+1].f << newl << cd[ti].s << " " << cd[ti+1].s << newl;
		   ti += 2;
	   }
   }
    
    
    
    
    return 0;
}
